````markdown
1. **What is the main purpose of reflection in Java?**

   - a) To dynamically load and execute arbitrary Java code at runtime.
   - b) To inspect and access the metadata (information) of a class at runtime, including its methods, fields, and annotations.
   - c) To achieve polymorphism by treating objects of different types as the same type.
   - d) To improve the performance of frequently called methods by bypassing type checking.

   **Answer: B**  
   Reflection is primarily used to inspect classes, methods, fields, and annotations at runtime, allowing programs to manipulate these elements dynamically.

2. **What is the difference between weak and soft references in Java?**

   - a) Weak references are always cleared by the garbage collector when memory is low, while soft references are never cleared.
   - b) Both weak and soft references are cleared by the garbage collector when memory is low, but weak references have priority for removal.
   - c) Weak references are cleared by the garbage collector as soon as there are no strong references to the object, while soft references persist even when memory is low.
   - d) There is no difference; both weak and soft references behave the same way.

   **Answer: C**  
   Weak references are cleared by the garbage collector as soon as the object is no longer reachable through strong references. Soft references, on the other hand, are cleared only when the JVM needs memory, making them more suitable for caching.

3. **When to choose between Serializable and Externalizable in Java?**

   - a) Use Serializable for simple object state serialization and Externalizable for complex object graphs.
   - b) Use Serializable for faster serialization and Externalizable for more control over the format.
   - c) Use Serializable and Externalizable interchangeably as they offer the same functionality.
   - d) Use Externalizable for thread-safe serialization.

   **Answer: B**  
   Serializable provides a default serialization mechanism that is easy to use and sufficient for many cases. Externalizable, on the other hand, allows developers to have complete control over the serialization process, which can be useful for optimizing performance or ensuring compatibility.

4. **Which of the following statements is NOT true about the Singleton pattern in Java?**

   - a) It ensures only one instance of a class exists throughout the application.
   - b) It provides a global point of access to the instance.
   - c) It can be easily implemented using the static keyword.
   - d) It guarantees thread safety.

   **Answer: D**  
   A basic Singleton implementation does not inherently guarantee thread safety. Special care, such as using synchronized methods or double-checked locking, is required to ensure thread safety.

5. **What is the core principle behind object-oriented programming (OOP) in Java?**

   - a) It organizes code around methods that manipulate data.
   - b) It focuses on breaking down problems into smaller, reusable components.
   - c) It emphasizes data encapsulation, where data and its manipulation logic are bundled together.
   - d) It prioritizes speed and efficiency through optimized algorithms and data structures.

   **Answer: C**  
   Encapsulation is a core principle of OOP, where data (attributes) and the methods (functions) that operate on that data are bundled together in a single unit called an object. This principle helps in protecting the data and ensuring that it is manipulated in a controlled manner.

6. **Can a Singleton pattern in Java ever return a different instance for the same class?**

   - a) Yes, if the Singleton is implemented using a lazy initialization approach.
   - b) Yes, if the Singleton class has a public constructor.
   - c) No, by definition, the Singleton pattern always guarantees a single instance.
   - d) Yes, if the application uses multiple class loaders.

   **Answer: D**  
   In Java, if multiple class loaders load the Singleton class, each class loader may create its own instance of the Singleton class. This can lead to multiple instances of the Singleton class in the same application.

7. **What are "synthetic bridge methods" in Java?**

   - a) Methods automatically generated by the compiler to handle covariant return types in inheritance.
   - b) Methods explicitly defined by the programmer to bridge between incompatible method signatures.
   - c) Methods used internally by the JVM for garbage collection purposes.
   - d) Methods created by the compiler during type erasure to ensure compatibility with generic types.

   **Answer: D**  
   Synthetic bridge methods are indeed created by the compiler during type erasure to ensure that generic types work correctly and maintain type compatibility, especially when classes are subclassed and methods are overridden.

8. **Which of the following statements is NOT true about interfaces and abstract classes in Java?**

   - a) Both can be used to define common functionalities for different classes.
   - b) Interface methods are implicitly public and abstract, whereas abstract class methods can have different access modifiers.
   - c) Interfaces can be used to achieve loose coupling, while abstract classes enforce tight coupling.
   - d) Both can be declared as public or package-private but cannot be declared as protected.

   **Answer: D**  
   While it is correct that interfaces and abstract classes cannot be declared as protected, interfaces cannot be declared as package-private either. An interface can only be declared public or left with no modifier (which means package-private). Abstract classes can be declared public, protected, package-private, or private (though private is rarely used).

9. **Consider the following scenario:**
   A Java application creates a large number of temporary objects during a specific processing phase. These objects are only needed within that phase and become immediately unreachable after the phase completes.  
   Which statement accurately describes the behavior of the generational garbage collector in this scenario, considering the potential impact on application performance?

   - a) The garbage collector will immediately reclaim memory for all temporary objects once the processing phase ends, minimizing any performance impact.
   - b) The garbage collector might trigger frequent, small collections throughout the processing phase, potentially leading to performance overhead.
   - c) The garbage collector will wait for a significant memory threshold to be reached before reclaiming memory, potentially causing a sudden pause during the processing phase.
   - d) The garbage collector's behavior is entirely unpredictable and cannot be controlled, leading to inconsistent application performance.

   **Answer: B**  
   This accurately describes the behavior of the generational garbage collector in handling a large number of temporary objects, which can lead to frequent minor garbage collections and potential performance overhead.

10. **In the context of multithreading, which of the following statements best describes the role of synchronization?**

    - a) Synchronization ensures that only one thread can access a shared resource at a time, preventing race conditions and data inconsistencies.
    - b) Synchronization guarantees that all threads accessing a shared resource will execute in a specific order, improving program efficiency.
    - c) Synchronization automatically creates copies of shared resources for each thread, allowing concurrent access without data conflicts.
    - d) Synchronization allows threads to communicate and share data directly, eliminating the need for separate copies of shared resources.

    **Answer: A**  
    Synchronization is used to control access to shared resources, ensuring that only one thread can access the resource at a time, thus preventing race conditions and maintaining data consistency.

11. **Which of the following statements is NOT true about checked and unchecked exceptions in Java?**

    - a) Checked exceptions are explicitly declared in the method signature, while unchecked exceptions are not.
    - b) Unchecked exceptions are generally considered more critical errors compared to checked exceptions.
    - c) The compiler enforces developers to handle checked exceptions, while unchecked exceptions can be left unhandled.
    - d) Both checked and unchecked exceptions inherit from the Exception class.

    **Answer: B**  
    This is not necessarily true. Unchecked exceptions usually represent programming errors (like `NullPointerException` or `ArrayIndexOutOfBoundsException`), which are often due to bugs in the code. However, they are not inherently more critical than checked exceptions, which can represent conditions that a reasonable application might want to catch and handle (like `IOException` or `SQLException`).

12. **Java Reflection and Class Loading: When invoking a method using reflection in Java, what is the difference between calling getMethod and getDeclaredMethod?**

    - a) getMethod returns only public methods, while getDeclaredMethod returns all methods including private ones.
    - b) getMethod searches the entire class hierarchy, while getDeclaredMethod only searches the current class.
    - c) Both methods are functionally identical and can be used interchangeably.
    - d) getMethod throws a NoSuchMethodException if the method doesn't exist, while getDeclaredMethod returns null.

    **Answer: A and B**  
    getMethod returns only public methods, including those inherited from superclasses, while getDeclaredMethod returns all methods (including private ones) declared in the class itself, not considering the inheritance hierarchy. Both methods throw a `NoSuchMethodException` if the specified method does not exist.

13. **Consider the following Java code snippet:**

    ```java
    public class MyClass {
        public static void printList(List list) {
            for (Object obj : list) {
                System.out.println(obj.toString());
            }
        }
    }
    ```

    What is the potential issue with the provided printList method and how can it be improved using Generics?

    - a) The method cannot handle lists containing different data types.
    - b) The method requires explicit type casting before printing objects.
    - c) Generics cannot be applied to existing code without rewriting the entire method.
    - d) This code snippet does not have any issues, it works correctly.

    **Answer: B**  
    The method is not type-safe and can lead to runtime errors if the objects in

the list do not have a `toString` method or if they are not of the expected type. This can be improved using generics:
`java
    public class MyClass {
        public static <T> void printList(List<T> list) {
            for (T obj : list) {
                System.out.println(obj.toString());
            }
        }
    }
    `
````
